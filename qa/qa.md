### 架构

# 技术选型

1. 初期架构方案选择
   - 快速实现
   - [ALL in one架构]()
   - 技术栈二选一PHP, JAVA
   - 这个阶段研发主要在写CURD业务逻辑，引入DAO和ORM能极大提高工程效率

2. 使用开源框架组件还是自研
    - 早期不建议自研
    - 随着规模的扩大，要控制技术栈
    - [要浅浅的封装一层]()
    - 适当的时候，造一些契合业务的轮子
    
3. 容量评估
    - 新系统上线
    - 临时运营活动
    - 系统容量有质变性增长
    - [容量设计五大步骤]()

4. 系统层面, 评估哪些指标
    - 网络带宽、CPU、内存容量、磁盘容量、磁盘IO等资源指标
    - 系统层面主要看吞吐量指标

5. 初期,系统存在瓶颈时优化原则
    - 最低成本，初期最大的成本是时间成本
    - 用“钱”和“资源”快速解决系统问题，而不是过早的系统重构
    - 将ALL in one架构升级为[伪分布式架构]()，是此阶段的最佳实践

6. 伪分布式
- 伪分布式的本质是单机变多机，但又不是真正的高可用，其核心是垂直拆分
  - 业务垂直拆分
  - 代码垂直拆分
  - 数据库垂直拆分
  - 研发团队垂直拆分
  - [伪分布式的优化细节]()

# 接入层架构

7. 接入层扩展
    - 反向代理
   
8. 常见的反向代理
    - Nginx
   
9. 引入反向代理要解决什么问题
   - 集群负载均衡([常见的负载均衡方法]())
   - [反向代理高可用]()
   
10. 接入层架构演进
    - 有反向代理技术之前，单体架构要解决扩展性问题，可使用[DNS轮询架构]()
    - 有[反向代理]()技术之后，初期可以使用反向代理解决扩展性问题
    - 升级为[高可用反向代理架构]()
    - [多级反向代理]()，引入LVS&F5进一步扩充性能
    - 无限性能，必须用[DNS轮询架构]()
    
11. Session一致性问题
    - [客户端层解决]()
    - [反向代理层解决]()
    - [web-server层解决]()
    - [后端服务层解决]()
    
12. CDN架构
    - 什么样的资源适合静态加速
    - CDN的架构是怎么样的
    - CDN是怎么实现“就近访问的”
    - 如何保证源站和镜像站数据的一致性
    - 资源更新，是推还是拉
    - 斯塔尔报告
    
13. TCP接入需要考虑的问题
    - TCP如何快速实现接入
    - TCP如何快速实现扩展，以及高可用
    - TCP如何快速实现负载均衡
    - TCP如何保证扩展性与耦合性的平衡
    - [综合方案，系统性解决负载均衡 + 高可用 + 可扩展 + 解耦合等一系列问题]()

# 性能优化

14. 早期常用的架构
    - ALL in one架构
15. 系统优化方向
    - 用最短时间，以对代码最小的冲击，极速扩充系统性能
16. 扩充系统性能
    - [三大分离]()的性能优化方法
17. 提升用户体验
    - [动静分离]()
18. 动静分离
- 动静分离，是“静态页面与动态页面，分开不同的系统访问”的架构设计方法
  - [如何实施]()
19. 页面静态化技术
- 将“原本需要动态生成的页面，提前生成静态页面”
  - [“页面静态化”]()技术，能够100倍提升访问速度
  - [适用场景]()
20. 早期系统瓶颈在哪
    - 数据库读性能
21. 提升数据库读性能
    - 读写分离，使用数据库分组架构，一主多从，主从同步，读写分离
    - [读写分离，水平切分都是使用数据库集群，有什么异同]()
22. 解决复杂SQL对数据库的影响
    - 前台与后台分离
    - [前后端分离，前台后台分离，是一回事么？如何快速实施前台与后台分离]()

# 微服务架构

23. 流行的技术栈
    - PHP语言的[LAMP]()栈
    - Java语言的[LiToMyJa]()栈
24. 业务快速发展,三层架构存在的问题
    - 代码频繁拷贝
    - 底层复杂性扩散
    - 公共库耦合
    - SQL质量不可控，数据库性能急剧下降
    - 数据库耦合，无法实现增加实例扩容
    
25. 解决三层架构可能出现的问题
    - [微服务架构]()解决以上问题
26. 微服务落地, 服务粒度选择
    - 统一服务层
    - 按业务划分服务
    - 按库划分服务
    - 按接口划分服务（需要轻量级进程等语言层面支持）
27. 微服务架构,可能遇到的问题
    - 系统复杂性上升
    - 层次间依赖关系变得复杂
    - 运维，部署更麻烦
    - 监控变得更复杂
    - 定位问题更麻烦
28. 微服务架构要解决什么问题
    - [高可用]()
    - [无限性能扩展]()
    - [负载均衡]()
29. 解决高可用问题
    - [虚IP]()
    - [反向代理]()
    - [集群]()
    - [连接池]()
    - [数据库分组]()
    - [缓存冗余]()
    - [故障转移]()
    - [高可用的方法论]()
30. 解决无限性能扩展问题
    - [Scale up]()
    - [Scale out]()
    - [DNS轮询]()
    - [反向代理]()
    - [连接池]()
    - [水平切分]()
    - [无限性能的方法论]()
31. 解决负载均衡问题
    - 同构均匀分摊
    - 异构按能力分摊
      - 静态权重法
      - 动态权重法，涉及[“保险丝”]()算法
        - 动态权重法还可以实现服务器的[过载保护]()
32. 和高可用, 无限性能扩展,负载均衡相关的组件
    - [连接池]()
33. 连接池
    - 两个核心数据结构：连接数组，锁数据
    - 三个核心接口：初始化，拿出连接，放回连接
    - [连接池内核]()
# 数据库架构

34. 工程上数据库设计
    - 根据“业务模式”设计[表结构]()
    - 根据“访问模式”设计[索引结构]()
35. 架构上数据库要考虑哪些
    - 读性能提升
    - 高可用
    - 一致性保障
    - 扩展性
    - 垂直拆分
36. 数据库读取速度提升
    - 建立索引
    - 增加从库
    - 增加缓存
37. 数据库分组集群, 主从同步, 读写分离,主库和从库创建不同索引
    - 主库只响应写请求，不建立索引
    - 线上从库，建立线上访问索引
    - 后台从库，建立后台访问索引
38. 数据库高可用
- 冗余+故障自动转移
  - 写库高可用，冗余写库
  - 读库高可用，冗余读库
39. 数据冗余带来的副作用
    - 两个写库数据可能不一致
    - 主库和从库数据可能不一致
40. 写库高可用,两个写库数据同步,自增ID方案
    - 为每个写库指定不同的初始值，相同的增长步长
    - 生成不同的ID
    - 一个写库提供服务，一个写库作为高可用影子主
41. 主从延时优化
    - 业务容忍
    - 强制读主
    - 在从库有可能读到旧数据时，[选择性读主]()
42. 底层表结构变更，水平扩展分库个数发生变化，底层存储引擎升级，数据库如何平滑过度
    - 如果业务能够接受，可以停服扩展
    - [追日志平滑扩容法]()，平滑过度
    - [双写平滑扩容法]()，平滑过度
    - [秒级平滑扩容法]()
    - [如何在秒级，实现读写实例加倍？容量加倍]()
43. 数据库垂直拆分的最佳实践
    - 数据库垂直拆分，尽量把：
      （1）长度短；
      （2）访问频率高；
      （3）经常一起访问；
      的数据放在主表里。

# 缓存架构

44. 工程上，缓存一般有几种使用方式
    - [进程内缓存]()
    - 进程外缓存，也就是[缓存服务]()
45. 多个服务使用进程内缓存，如何保证一致性
    - 服务节点同步通知
    - MQ异步通知
    - 牺牲少量一致性，定期后端更新
46. 使用缓存服务，缓存的使用的注意点
    - 服务与服务之间不要通过缓存传递数据
    - 如果缓存挂掉，可能导致雪崩，此时要做高可用缓存，或者水平切分
    - 调用方不宜再单独使用缓存存储服务底层的数据，容易出现数据不一致，以及反向依赖
    - 不同服务，缓存实例要做垂直拆分，不宜共用缓存
47. 缓存操作细节，最佳实践
    - [Cache Aside Pattern]()
48. Cache Aside Pattern
- 它分为读缓存最佳实践，以及写缓存最佳实践
  - 读缓存最佳实践
    - 先读缓存，命中则返回；未命中则读数据库，然后设置缓存
  - 写缓存最佳实践
    - 淘汰缓存，而不是修改缓存
    - 先操作数据库，再操作缓存
49. 缓存的本质是“冗余了数据库中的数据”,可能存在什么问题
    - 缓存与数据库[数据不一致]()
50. 什么场景下容易出现不一致
    - 写[后立即读]()业务场景
51. 出现不一致时，优化思路
    - 及时把缓存中的脏数据淘汰掉
52. 具体要怎么淘汰，保证缓存与数据库中数据的一致性
    - 服务同步二次淘汰法
    - 服务异步二次淘汰法
    - 线下异步二次淘汰法
    - [二次淘汰法，是很常见的一种实践]()
53. 最常用的缓存服务
    - Redis和memcache
54. 什么时候选择使用Redis
    - 需要支持复杂数据结构
    - 需要支持持久化
    - 需要天然高可用
    - value存储内容比较大
    - 如果只是[纯KV，可以使用memcache]()

# 解耦

55. 依赖（调用）某个下游服务集群，将下游集群信息放在自身配置文件里是一种惯用做法，该做法可能导致什么问题
56. 常见的配置架构演进
57. 什么时候不使用MQ
58. 什么时候使用MQ来解耦
59. 上下游IP耦合,如何解耦
60. 多个模块,公共库而耦合在一起, 如何解耦
61. 多个模块,数据库而耦合在一起, 如何解耦
62. 微服务拆分不完全,导致耦合, 如何解耦

# 分层架构

63. 系统架构分层会越来越多的原因
64. 每次都要连接数据库获取数据,编码非常低效,有什么痛点
65. 优化64
66. 单体架构,编码非常低效,有什么痛点
67. 优化66
68. 微服务架构,编码非常低效,有什么痛点
69. 优化68
70. PC/H5/APP多端业务,编码非常低效,有什么痛点
71. 优化70
72. 大数据量,高并发量的微服务架构,编码非常低效,有什么痛点
73. 优化72

# 架构进阶

74. 负载均衡、数据收集、服务发现、调用链跟踪。这些非业务的功能,一般是谁实现的呢
75. 对于74中“黑科技”的使用与推广,存在什么问题
76. 如何优化
77. Service Mesh的行业开源最佳实践
78. Istio的架构核心
79. 单机房架构的特点
80. 理想化的多机房架构
81. 理想化的多机房架构,存在什么问题
82. 折衷方案
83. 什么是“折衷多机房架构”?
84. 折衷多机房架构，有什么优点
