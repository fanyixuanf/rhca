# TopK

- ### eg: 从arr={5,8,2,3,6,4,1,7,9,4,6,2} 中找出最大的5个数

## 方案1 - 排序
- 将n个数排序之后取出最大的k个

## 方案二 - 局部排序
- 用冒泡排序, 每次排序找出一个最大值, 冒k个泡,得到Topk

## 方案三 - 堆
- 先用前k个元素生成一个小顶堆,用于存放当前最大的k个元素
- 从k+1个元素开始扫描,和堆顶(小顶堆)元素比较,如果被扫描的元素大于堆顶, 替换堆顶的元素,调整堆,保证堆内的k个元素总是当前最大的k个元素.

## 方案四 - 随机选择+partition
- partition把整体分为两部分
- 用数组的第一个元素,划分成左右两个子数组
  - 左半部分比k大
  - 右半部分比k小
  - 中间位置是划分元素

- 典型的减治算法，递归内的两个分支，最终只会执行一个
- 如果i大于k，则说明arr[i]左边的元素都大于k，于是只递归arr[1, i-1]里第k大的元素即可;
- 如果i小于k，则说明说明第k大的元素在arr[i]的右边，于是只递归arr[i+1, n]里第k-i大的元素即可;

1. 分治法，大问题分解为小问题，小问题都要递归各个分支，例如：快速排序;
2. 减治法，大问题分解为小问题，小问题只要递归一个分支，例如：二分查找，随机选择;

快速排序的核心算法思想是分治法:
- 分治法（Divide&Conquer），把一个大的问题，转化为若干个子问题（Divide），每个子问题“都”解决，大的问题便随之解决（Conquer）。这里的关键词是“都”。从伪代码里可以看到，快速排序递归时，先通过partition把数组分隔为两个部分，两个部分“都”要再次递归。
- 减治法（Reduce&Conquer），把一个大的问题，转化为若干个子问题（Reduce），这些子问题中“只”解决一个，大的问题便随之解决（Conquer）。这里的关键词是“只”。
  - 二分查找binary_search，BS，是一个典型的运用减治法思想的算法.
